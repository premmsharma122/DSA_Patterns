# Slow and Fast Pointers

## Overview

Slow and Fast Pointers technique linear data structures me use hoti hai jaise arrays, linked lists, ya strings. Ye technique problems ko **ek pass me** solve karne me help karti hai aur **O(1) extra space** me kaam karti hai, memory efficient hai.

---

## Kab Use Karein

* Linked list me cycle detect karne ke liye.
* Linked list me middle element find karne ke liye.
* Linear structures me single pass traversal karne ke liye jahan minimal memory chahiye.

---

## Kyu Use Karein

* Cycle detection ke liye normally previous nodes store karna padta hai, jo **O(N) space** lega.
* Slow and fast pointer use karke cycle detect O(1) space me ho sakta hai.
* Middle node find karne me ek hi traversal me result mil jaata hai.

---

## Kaise Use Karein

1. Do pointers banao: `slow` aur `fast` head se start.
2. Loop me: `slow` ko **1 step** aage bhejo aur `fast` ko **2 steps** aage.
3. Condition check karo:

   * **Cycle Detection:** agar `slow == fast` â†’ cycle hai.
   * **Middle Node:** jab `fast` end me ho, `slow` middle me hoga.

---

## Java Template

```java
class Node {
    int val;
    Node next;
    Node(int val) { this.val = val; }
}

public class SlowFastPointers {

    // Linked list me cycle detect kare
    public Node detectCycle(Node head) {
        Node slow = head;
        Node fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            // Cycle detect hua
            if (slow == fast) {
                return slow; // Meeting point
            }
        }
        return null; // Cycle nahi hai
    }

    // Linked list me middle node find kare
    public Node findMiddle(Node head) {
        Node slow = head;
        Node fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow; // Middle node
    }

    public static void main(String[] args) {
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

        SlowFastPointers sf = new SlowFastPointers();

        Node middle = sf.findMiddle(head);
        System.out.println("Middle node: " + middle.val); // Output: 3

        // Example cycle create
        head.next.next.next.next.next = head.next; // cycle
        Node cycle = sf.detectCycle(head);
        System.out.println("Cycle detected at node: " + (cycle != null ? cycle.val : "No cycle"));
    }
}

```
