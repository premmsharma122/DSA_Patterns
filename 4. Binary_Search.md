# Binary Search
## 1️⃣ Problem
Aapke paas ek **sorted array** hai:

Aur aapko koi number **jaldi se find karna** hai, jaise `7`.  

- **Simple approach:** ek-ek element check karo → O(n) time  
- **Binary Search:** array sorted hai, isliye O(log n) time me mil jayega  

---

## 2️⃣ Kab Use Kare

- Jab array ya list **sorted ho** aur **fast search chahiye**  
- Jab **insert position** find karni ho sorted array me  
- Jab array me **duplicates ho** aur **leftmost/rightmost occurrence** find karni ho  
- Jab **rotated sorted array** ho (jaise `[4,5,6,1,2,3]`)  

---

## 3️⃣ Technique (Ashan bhasa)

- Start do pointers: `left = 0`, `right = n-1`  
- Mid find karo:

- Compare karo `array[mid]` aur `target`:

1. **array[mid] == target** → mil gaya  
2. **array[mid] < target** → target **right side** me hai → `left = mid + 1`  
3. **array[mid] > target** → target **left side** me hai → `right = mid - 1`  

- Repeat karo jab tak `left > right` → target nahi mila  

---

### Visualization

Array: `[1, 3, 5, 7, 9, 11]`  
Target = `7`

1. left=0, right=5 → mid=2 → array[2]=5  
   - 5 < 7 → right side me move → left=3  
2. left=3, right=5 → mid=4 → array[4]=9  
   - 9 > 7 → left side me move → right=3  
3. left=3, right=3 → mid=3 → array[3]=7 ✅ mil gaya  

---

## 4️⃣ Variations

1. **Leftmost / rightmost occurrence** → duplicates handle karne ke liye  
2. **Rotated sorted array** → check karo kaunsa half sorted hai aur target waha search karo  

---

## 5️⃣ Java Code

```java
public class BinarySearchExample {

    // Classic binary search
    public static int binarySearch(int[] arr, int target) {
        int left = 0, right = arr.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (arr[mid] == target) return mid;
            else if (arr[mid] < target) left = mid + 1;
            else right = mid - 1;
        }

        return -1; // nahi mila
    }

    // Rotated sorted array me search
    public static int searchRotated(int[] arr, int target) {
        int left = 0, right = arr.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) return mid;

            // left half sorted hai
            if (arr[left] <= arr[mid]) {
                if (arr[left] <= target && target <= arr[mid]) right = mid - 1;
                else left = mid + 1;
            } 
            // right half sorted hai
            else {
                if (arr[mid] <= target && target <= arr[right]) left = mid + 1;
                else right = mid - 1;
            }
        }

        return -1; // nahi mila
    }

    public static void main(String[] args) {
        int[] arr = {1, 3, 5, 7, 9, 11};
        System.out.println(binarySearch(arr, 7)); // Output: 3

        int[] rotated = {4,5,6,1,2,3};
        System.out.println(searchRotated(rotated, 2)); // Output: 4
    }
}
```
##  6️⃣ Kyun aur kahan use kare
-   Kyun: Sorted data me search fast chahiye, O(log n) time me instead of O(n)
-   Kahan: Sorted arrays, lists, rotated arrays, duplicates, insert positions

